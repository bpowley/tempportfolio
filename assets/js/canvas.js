// Generated by CoffeeScript 1.6.3
(function() {
  var imageObj;

  window.canvasSize = 512;

  window.drawingSize = 256;

  window.texturedDrawing = true;

  imageObj = new Image();

  imageObj.src = '../shared/grungetex.png';

  window.vectorDrawing = function(strokes) {
    var maxCoordX, maxCoordY, minCoordX, minCoordY, p, stroke, sum, totalPoints, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    this.cvs = document.createElement('canvas');
    this.cvs.width = window.canvasSize;
    this.cvs.height = window.canvasSize;
    this.ctx = this.cvs.getContext('2d');
    this.ctx.clearRect(0, 0, window.canvasSize, window.canvasSize);
    maxCoordX = -99999;
    minCoordX = 99999;
    maxCoordY = -99999;
    minCoordY = 99999;
    totalPoints = 0;
    for (_i = 0, _len = strokes.length; _i < _len; _i++) {
      stroke = strokes[_i];
      totalPoints += stroke.p.length;
      _ref = stroke.p;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        p = _ref[_j];
        if (p[0] > maxCoordX) {
          maxCoordX = p[0];
        }
        if (p[1] > maxCoordY) {
          maxCoordY = p[1];
        }
        if (p[0] < minCoordX) {
          minCoordX = p[0];
        }
        if (p[1] < minCoordY) {
          minCoordY = p[1];
        }
      }
    }
    this.intSize = Math.max(maxCoordX - minCoordX, maxCoordY - minCoordY);
    this.extSize = window.canvasSize * 0.9;
    this.offsX = minCoordX;
    this.offsY = minCoordY;
    this.time = 0;
    this.keyframes = [0];
    sum = 0;
    for (_k = 0, _len2 = strokes.length; _k < _len2; _k++) {
      stroke = strokes[_k];
      sum += stroke.p.length;
      this.keyframes.push(sum / totalPoints);
      stroke.w *= this.extSize / this.intSize;
      stroke.w = Math.min(stroke.w, window.drawingSize / 10);
      stroke.w = Math.max(stroke.w, window.drawingSize / 17);
      _ref1 = stroke.p;
      for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
        p = _ref1[_l];
        p[0] = (p[0] - this.offsX) / this.intSize * this.extSize + this.extSize * .05;
        p[1] = (p[1] - this.offsY) / this.intSize * this.extSize + this.extSize * .05;
      }
    }
    this.keyframes.push(1);
    this.updated = function() {};
    this.draw = function(newTime) {
      var i, isLast, lastIndex, lastTime, lowerBound, renderTime, xc, yc, _len4, _m, _n, _ref2;
      newTime = Math.min(newTime, 1);
      lastTime = this.time;
      this.time = newTime;
      renderTime = new Date().getTime();
      for (i = _m = 0, _len4 = strokes.length; _m < _len4; i = ++_m) {
        stroke = strokes[i];
        if (!(this.keyframes[i] <= lastTime + .02 && this.keyframes[i + 1] >= this.time - .02)) {
          continue;
        }
        isLast = (i === strokes.length - 1) || (this.keyframes[i + 1] > this.time);
        lowerBound = this.keyframes[i];
        lastIndex = isLast ? Math.ceil((stroke.p.length - 1) * Math.min(1, (this.time - lowerBound) / (this.keyframes[i + 1] - lowerBound))) : stroke.p.length - 1;
        this.ctx.fillStyle = stroke.c;
        this.ctx.strokeStyle = stroke.c;
        this.ctx.lineWidth = stroke.w;
        this.ctx.beginPath();
        this.ctx.lineCap = "round";
        this.ctx.lineJoin = "round";
        p = stroke.p;
        if (lastIndex < 2) {
          this.ctx.moveTo(p[0][0], p[0][1]);
          this.ctx.lineTo(p[0][0] + 1, p[0][1] + 1);
          this.ctx.stroke();
        } else {
          this.ctx.moveTo(p[0][0], p[0][1]);
          i = 1;
          for (i = _n = 1, _ref2 = lastIndex - 2; 1 <= _ref2 ? _n <= _ref2 : _n >= _ref2; i = 1 <= _ref2 ? ++_n : --_n) {
            xc = (p[i][0] + p[i + 1][0]) / 2;
            yc = (p[i][1] + p[i + 1][1]) / 2;
            this.ctx.quadraticCurveTo(p[i][0], p[i][1], xc, yc);
          }
          if (lastIndex > 2 && i + 1 < p.length) {
            this.ctx.quadraticCurveTo(p[i][0], p[i][1], p[i + 1][0], p[i + 1][1]);
            this.ctx.lineTo(p[i + 1][0], p[i + 1][1]);
          } else if (lastIndex === 2) {
            this.ctx.lineTo(p[1][0], p[1][1]);
          }
          this.ctx.stroke();
        }
      }
      this.updated();
      renderTime = new Date().getTime() - renderTime;
      if (renderTime > 40 && this.time < 1) {
        return this.time = 0.99;
      }
    };
    return this;
  };

}).call(this);
