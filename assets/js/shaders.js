// Generated by CoffeeScript 1.6.3
(function() {
  var caDir, caProb, programs;

  caProb = 0;

  caDir = 0;

  window.drawings.prerenderOps.push(function(frame) {
    caProb = Math.random();
    return caDir += 0.1;
  });

  window.programs = programs = {
    vertexProjection: "	uniform	    mat4 	transform;\n	uniform 	mat4 	cameraInverse;\n	uniform 	mat4 	cameraProjection;\n\n	attribute 	vec3 	vertices;\n	attribute   vec2    uvs;\n\n	varying     vec2    uv;\n\n	void main(void)\n	{\n		uv = uvs;\n		gl_Position = cameraProjection * cameraInverse * transform * vec4( vertices, 1.0 );\n	}",
    texture: "#ifdef GL_ES\n	precision highp float;\n#endif\n\nuniform 	sampler2D 	texture;\nvarying 	vec2		uv;\n\nvoid main( void )\n{\n	gl_FragColor = texture2D( texture, uv );\n}",
    chromatic: "#ifdef GL_ES\n	precision highp float;\n#endif\n\n#define OFFS 2.0943951023\n\nuniform 	sampler2D 	fboTexture;\nvarying 	vec2		uv;\nuniform 	float 		amount;\nuniform 	float 		angle;\n\nvoid main( void )\n{\n	vec4 rc = texture2D( fboTexture, vec2(uv.x+cos(angle)*amount,uv.y+sin(angle)*amount) );\n	vec4 gc = texture2D( fboTexture, vec2(uv.x+cos(angle+OFFS)*amount,uv.y+sin(angle+OFFS)*amount) );\n	vec4 bc = texture2D( fboTexture, vec2(uv.x+cos(angle-OFFS)*amount,uv.y+sin(angle-OFFS)*amount) );\n\n	float a = min(rc.a + gc.a + bc.a,1.0);\n\n	gl_FragColor = vec4(rc.r,gc.g,bc.b,a);\n}",
    blur: "#ifdef GL_ES\n	precision highp float;\n#endif\n\nuniform sampler2D fboTexture;\n        uniform vec2 delta;\n        varying vec2 uv;\n\n        float random(vec3 scale, float seed) {\n        	return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    	}\n\n        void main() {\n            vec4 color = vec4(0.0);\n            float total = 0.0;\n            \n            // Add an element of randomness to prevent banding in the blur\n            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n            \n            // For each pixel\n            for (float t = -10.0; t <= 10.0; t++) {\n\n            	// Calculate the weight based on triangle-wave percentage\n                float percent = (t + offset - 0.5) / 10.0;\n                float weight = 1.0 - abs(percent);\n\n                // Get the texture coordinate\n                vec4 sample = texture2D(fboTexture, uv + delta * percent);\n                \n                // Premultiply the alpha. This is very important here\n                sample.rgb *= sample.a;\n                \n             	// Accumulate Data\n                color += sample * weight;\n                total += weight;\n            }\n            \n            //web.archive.org/web/20141006141849/http://vec4/ og = texture2D(fboTexture, uv);\n	//web.archive.org/web/20141006141849/http://float/ a = og.a;\n\n            // Divide out the average\n            gl_FragColor = color / total;\n            \n           	// Unpremultiply the alpha\n            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n        }"
  };

  window.shaders = {
    texture: function(texture, camera, size) {
      return {
        vertexShader: programs.vertexProjection,
        fragmentShader: programs.texture,
        data: {
          texture: texture,
          transform: new GLOW.Matrix4(),
          cameraInverse: camera.inverse,
          cameraProjection: camera.projection,
          vertices: GLOW.Geometry.Plane.vertices(size, false),
          uvs: GLOW.Geometry.Plane.uvs()
        },
        indices: GLOW.Geometry.Plane.indices()
      };
    },
    chromatic: function(FBO, camera, size, distance, angle) {
      return {
        vertexShader: programs.vertexProjection,
        fragmentShader: programs.chromatic,
        data: {
          fboTexture: FBO,
          amount: new GLOW.Float(distance / size),
          angle: new GLOW.Float(angle),
          transform: new GLOW.Matrix4(),
          cameraInverse: camera.inverse,
          cameraProjection: camera.projection,
          vertices: GLOW.Geometry.Plane.vertices(size, false),
          uvs: GLOW.Geometry.Plane.uvs()
        },
        indices: GLOW.Geometry.Plane.indices()
      };
    },
    glow: function(FBO, camera, size, isVertical, distance) {
      return {
        vertexShader: programs.vertexProjection,
        fragmentShader: programs.blur,
        data: {
          fboTexture: FBO,
          delta: new GLOW.Float([(!isVertical ? distance / size : 0), (isVertical ? distance / size : 0)]),
          transform: new GLOW.Matrix4(),
          cameraInverse: camera.inverse,
          cameraProjection: camera.projection,
          vertices: GLOW.Geometry.Plane.vertices(size, false),
          uvs: GLOW.Geometry.Plane.uvs()
        },
        indices: GLOW.Geometry.Plane.indices()
      };
    }
  };

  window.filters = {
    draw: function(Texture, Camera, Size) {
      return {
        shader: new GLOW.Shader(window.shaders.texture(Texture, Camera, Size)),
        setup: (function() {}),
        prepare: (function() {}),
        "delete": function() {
          return this.shader.dispose();
        }
      };
    },
    chromatic: function(Texture, Camera, Size, Distance, Angle, Chance) {
      return {
        shader: new GLOW.Shader(window.shaders.chromatic(Texture, Camera, Size, Distance, Angle)),
        setup: function(shader) {},
        prepare: function(shader) {
          shader.angle.set(caDir);
          return shader.amount.set(caProb < 1 / Chance ? Distance / Size : 0);
        },
        "delete": function() {
          return this.shader.dispose();
        }
      };
    },
    glowHorizontal: function(Texture, Camera, Size, Distance) {
      return {
        shader: new GLOW.Shader(window.shaders.glow(Texture, Camera, Size, false, Distance)),
        setup: function(shader) {},
        prepare: function(shader) {},
        "delete": function() {
          return this.shader.dispose();
        }
      };
    },
    glowVertical: function(Texture, Camera, Size, Distance) {
      return {
        shader: new GLOW.Shader(window.shaders.glow(Texture, Camera, Size, true, Distance)),
        setup: function(shader) {},
        prepare: function(shader) {},
        "delete": function() {
          return this.shader.dispose();
        }
      };
    }
  };

}).call(this);
